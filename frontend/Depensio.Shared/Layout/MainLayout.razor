@inherits LayoutComponentBase
@inject NavigationManager NavManager 
@inject IMenuService _menuService
@inject IBoutiqueService _boutiqueService



<ToastContainer />
<CascadingAuthenticationState>
    <RouteGuard RedirectToLogin="/login" RedirectToAccessDenied="/access_denied"  RedirectToLogout="/logout" TimeoutLogout="1800000">
        
        <LoadingComponent IsLoad="@isLoad" />
        @if (menuUsers.Any())
        {
            @if (!HasAccess)
            {
                <NotFoundComponent />
                return;
            }
           <NavBarDashboard OnAfterToggleSidebar="()=>{
                isSidebarOpen = !isSidebarOpen;
            }" IsSidebarOpen="@isSidebarOpen" />

            <div class="flex pt-16 overflow-hidden bg-gray-50 dark:bg-gray-900">

                <Sidebar 
                    boutique="@boutique" 
                    IsSidebarOpen="@isSidebarOpen" 
                    OnClose="()=>{
                        isSidebarOpen = !isSidebarOpen;
                    }" 
                    menuUsers="@menuUsers"
                />

                <div id="main-content" class="relative w-full min-h-screen overflow-y-auto bg-gray-50 lg:ml-64 dark:bg-gray-900">
                    <main>
                        @Body
                    </main>
                    <FooterDashboard />
                </div>

            </div>
    
        }
        
        <!-- Chatbot Modal -->
        <ChatbotComponent />

        </RouteGuard>
</CascadingAuthenticationState>


@code {
    private bool isSidebarOpen = false;

    private Guid boutiqueId;
    private List<MenuUser> menuUsers = new();
    private bool HasAccess = true;    
    private bool isLoad = true;
    private BoutiqueDTO boutique = new();

    protected override async Task OnInitializedAsync()
    {
        isLoad = true;        
        boutiqueId = NavigationHelper.ExtractGuidFromUri(NavManager);

        await GetMenuByUserBoutiqueAsync(boutiqueId);
        await GetOneBoutiqueByUser(boutiqueId);
        isLoad = false; 
    }

    private async Task GetMenuByUserBoutiqueAsync(Guid _boutiqueId)
    {
        var menureponse = await _menuService.GetMenuByUserBoutiqueAsync(_boutiqueId);
        menuUsers = menureponse.Data.Menus.ToList();
    
        if (!menuUsers.Any()) 
        {
            HasAccess = false;
            return;
        }
    
        var currentPath = $"/{NavManager.ToBaseRelativePath(NavManager.Uri)}";
        HasAccess = menuUsers.Any(m => IsUrlMatchExact(currentPath, m.UrlFront, _boutiqueId));
    }

    private bool IsUrlMatchExact(string currentUrl, string menuTemplate, Guid boutiqueId)
    {
        // Remplacer les placeholders
        var resolvedMenuUrl = menuTemplate
            .Replace("{boutiqueid}", boutiqueId.ToString(), StringComparison.OrdinalIgnoreCase)
            .Replace("{boutiqueId}", boutiqueId.ToString(), StringComparison.OrdinalIgnoreCase);
    
        // Séparer en segments
        var currentSegments = currentUrl.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
        var menuSegments = resolvedMenuUrl.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
    
        // Vérifier que l'URL actuelle a au moins le même nombre de segments
        if (currentSegments.Length < menuSegments.Length)
            return false;
    
        // Comparer uniquement les N premiers segments (N = nombre de segments du menu)
        for (int i = 0; i < menuSegments.Length; i++)
        {
            if (!currentSegments[i].Equals(menuSegments[i], StringComparison.OrdinalIgnoreCase))
                return false;
        }
    
        return true;
    }

    private async Task GetOneBoutiqueByUser(Guid _boutiqueId)
    {
        var resultBoutique = await _boutiqueService.GetOneBoutiqueByUser(_boutiqueId);
        boutique = resultBoutique.Data.Boutique;
    
    }
}